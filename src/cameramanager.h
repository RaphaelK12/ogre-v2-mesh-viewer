/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#pragma once

#include "Ogre.h"
#include <limits>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QWheelEvent>

enum CameraMode   // enumerator values for different styles of camera movement
{
    CM_BLENDER,
    CM_FLY,	    // WIP
    CM_ORBIT    // WIP
};

enum View
{
    VI_TOP,
    VI_LEFT,
    VI_BOTTOM,
    VI_RIGHT,
    VI_FRONT,
    VI_BACK,
    VI_USER
};

enum Direction
{
    DR_FORWARD,
    DR_BACKWARD,
    DR_LEFT,
    DR_RIGHT
};

/****************************************************************************
 * This class manages the ogre camera and transalates Qt events to camera
 * actions
***************************************************************************/
class CameraManager
{
public:
    CameraManager(Ogre::Camera* cam);
    ~CameraManager();

    void setCamera(Ogre::Camera* cam);
    Ogre::Camera* getCamera() { return mCamera; }

    void setTarget(Ogre::SceneNode* target);
    Ogre::SceneNode* getTarget() { return mTarget; }

    void manualStop();
    Ogre::Real getDistanceFromTarget() { return mDistFromTarget; }

    void setYawPitchDist(Ogre::Radian yaw, Ogre::Radian pitch, Ogre::Real dist);

    void setMode(CameraMode mode);
    CameraMode getMode() { return mMode; }

    void setProjectionType(Ogre::ProjectionType pt);
    Ogre::ProjectionType getProjectionType() { return mCamera->getProjectionType(); }

    View getView() { return mCurrentView; }
    void setView(View newView);

    void rotatePerspective(Direction dir);
    void numpadViewSwitch(const QKeyEvent* evt);

    /*-----------------------------------------------------------------------------
    | Per-frame updates.
    -----------------------------------------------------------------------------*/
    bool frameRenderingQueued(const Ogre::FrameEvent &evt)
    {
        if (mMode == CM_FLY)
        {
            // build our acceleration vector based on keyboard input composite
            Ogre::Vector3		accel = Ogre::Vector3::ZERO;
            if (mGoingForward)	accel += mCamera->getDirection();
            if (mGoingBack)		accel -= mCamera->getDirection();
            if (mGoingRight)	accel += mCamera->getRight();
            if (mGoingLeft)		accel -= mCamera->getRight();
            if (mGoingUp)		accel += mCamera->getUp();
            if (mGoingDown)		accel -= mCamera->getUp();

            // if accelerating, try to reach top speed in a certain time
            Ogre::Real topSpeed = mShiftDown ? mTopSpeed * 20 : mTopSpeed;
            if (accel.squaredLength() != 0)
            {
                accel.normalise();
                mVelocity += accel * topSpeed * evt.timeSinceLastFrame * 10;
            }
            // if not accelerating, try to stop in a certain time
            else mVelocity -= mVelocity * evt.timeSinceLastFrame * 10;

            Ogre::Real tooSmall = std::numeric_limits<Ogre::Real>::epsilon();

            // keep camera velocity below top speed and above epsilon
            if (mVelocity.squaredLength() > topSpeed * topSpeed)
            {
                mVelocity.normalise();
                mVelocity *= topSpeed;
            }
            else if (mVelocity.squaredLength() < tooSmall * tooSmall)
                mVelocity = Ogre::Vector3::ZERO;

            if (mVelocity != Ogre::Vector3::ZERO) mCamera->move(mVelocity * evt.timeSinceLastFrame);
        }
        return true;
    }

    /*-----------------------------------------------------------------------------
    | Processes key presses for free-look style movement.
    -----------------------------------------------------------------------------*/
    void injectKeyDown(const QKeyEvent *evt)
    {
        if (mMode == CM_FLY)
        {
            if (evt->key() == Qt::Key_W)
            {
                mGoingForward = true;
            }
            else if (evt->key() == Qt::Key_A)
            {
                mGoingLeft = true;
            }
            else if (evt->key() == Qt::Key_S)
            {
                mGoingBack = true;
            }
            else if (evt->key() == Qt::Key_D)
            {
                mGoingRight = true;
            }
        }
        if (evt->key() == Qt::Key_Shift)
        {
            mShiftDown = true;
        }
        if (mMode == CM_BLENDER)
        {
            Ogre::Vector3 accel = Ogre::Vector3::ZERO;
            if (evt->key() == Qt::Key_W)
            {
                accel += mCamera->getDirection();
            }
            else if (evt->key() == Qt::Key_A)
            {
                accel -= mCamera->getRight();
            }
            else if (evt->key() == Qt::Key_S)
            {
                accel -= mCamera->getDirection();
            }
            else if (evt->key() == Qt::Key_D)
            {
                accel += mCamera->getRight();
            }
            if (accel != Ogre::Vector3::ZERO)
            {
                accel.normalise();
                mCamera->move(accel * 1.5);
            }

            numpadViewSwitch(evt);
        }
    }

    /*-----------------------------------------------------------------------------
    | Processes key releases for free-look style movement.
    -----------------------------------------------------------------------------*/
    void injectKeyUp(const QKeyEvent* evt)
    {
        if (evt->key() == Qt::Key_W)
            mGoingForward = false;
        else if (evt->key() == Qt::Key_A)
            mGoingLeft = false;
        else if (evt->key() == Qt::Key_S)
            mGoingBack = false;
        else if (evt->key() == Qt::Key_D)
            mGoingRight = false;
        if (evt->key() == Qt::Key_Shift)
            mShiftDown = false;
    }

    /*-----------------------------------------------------------------------------
    | Processes mouse movement differently for each style.
    -----------------------------------------------------------------------------*/
    void injectMouseMove(Ogre::Vector2 mousePos)
    {
        if (mMode == CM_FLY)
        {
            mCamera->yaw(Ogre::Degree(-mousePos.x * 0.15f));
            mCamera->pitch(Ogre::Degree(-mousePos.y * 0.15f));
        }
        if (mMode == CM_BLENDER || mMode == CM_ORBIT)
        {
            if (mOrbiting && !mShiftDown)
            {
                rotate(mousePos.x, mousePos.y);
                if (mCurrentView != VI_USER)
                    mCurrentView = VI_USER;
            }
            else if ((mOrbiting && mShiftDown) && mMode == CM_BLENDER)
            {
                pan(mousePos.x, mousePos.y);
            }
        }
    }

    void injectMouseWheel(const QWheelEvent* evt)
    {
        mMouseWheelDelta = evt->delta();
        //qDebug() << (uint64_t)mCamera << ", " << (uint64_t)mTarget;
        mDistFromTarget = (mCamera->getPosition() - mTarget->_getDerivedPositionUpdated()).length();
        mCamera->moveRelative(Ogre::Vector3(0, 0, -mMouseWheelDelta * 0.0008f * mDistFromTarget));
    }

    void injectMouseDown(const QMouseEvent* evt)
    {
        if (mMode == CM_BLENDER || mMode == CM_ORBIT)
        {
            if (evt->button() == Qt::MiddleButton || evt->button() == Qt::LeftButton)
            {
                mOrbiting = true;
            }
        }
    }

    /*-----------------------------------------------------------------------------
    | Processes mouse releases. Only applies for orbit style.
    | Left button is for orbiting, and right button is for zooming.
    -----------------------------------------------------------------------------*/
    void injectMouseUp(const QMouseEvent* evt)
    {
        if (mMode == CM_BLENDER || mMode == CM_ORBIT)
        {
            if (evt->button() == Qt::MiddleButton || evt->button() == Qt::LeftButton)
            {
                mOrbiting = false;
            }
        }
    }

    void rotate(int x, int y)
    {
        mCameraNode->yaw(Ogre::Degree(-x * 0.4f), Ogre::Node::TS_PARENT);
        mCameraNode->pitch(Ogre::Degree(-y * 0.4f));
    }

    void pan(int x, int y)
    {
        Ogre::Vector3 transVector(-x, y, 0);
        if (mTarget)
        {
            mDistFromTarget = (mCamera->getPosition() - mTarget->_getDerivedPositionUpdated()).length();
            if (mTarget->numAttachedObjects() > 0 && mTarget->getAttachedObject(0))
                transVector *= mTarget->getAttachedObject(0)->getWorldRadius() * (mDistFromTarget / 10000.0f);
            //transVector *= mTarget->getAttachedObject(0)->getBoundingRadius() * (mDistFromTarget / 10000.0f);
        }
        mCameraNode->translate(transVector, Ogre::Node::TS_LOCAL);
    }

protected:

    Ogre::Camera* mCamera = nullptr;

    Ogre::SceneNode* mTarget = nullptr;
    Ogre::SceneNode* mCameraNode = nullptr;

    bool mOrbiting = false;
    bool mShiftDown = false;
    bool mGoingForward = false;
    bool mGoingBack = false;
    bool mGoingLeft = false;
    bool mGoingRight = false;
    bool mGoingUp = false;
    bool mGoingDown = false;

    Ogre::Real mDistFromTarget = 0.0;
    Ogre::Real mTopSpeed = 15;
    Ogre::Vector3 mVelocity = Ogre::Vector3::ZERO;
    int mMouseWheelDelta = 0;

    View mCurrentView = VI_USER;
    CameraMode mMode = CM_FLY;
};

