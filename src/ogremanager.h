/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#pragma once

#include <QObject>


namespace Ogre
{
    class Root;
    class Timer;
    class RenderSystem;
    class SceneManager;

    namespace v1
    {
        class OverlaySystem;
    }
}

class MyHlmsListener;
class OgreWidget;


static const std::string OGRE_RENDERSYSTEM_DIRECTX11 = "Direct3D11 Rendering Subsystem";
static const std::string OGRE_RENDERSYSTEM_OPENGL3PLUS = "OpenGL 3+ Rendering Subsystem";


class OgreManager : public QObject
{
    Q_OBJECT

public:
	OgreManager();
	virtual ~OgreManager();
	void initialize();
	void renderOgreWidgetsOneFrame();

    void createScene();

	int  registerOgreWidget( OgreWidget* ogreWidget );
	void unregisterOgreWidget( int ogreWidgetId );
	
    OgreWidget* getOgreWidget( int ogreWidgetId ) const;
    Ogre::Root* getOgreRoot() const { return mRoot; }
    Ogre::SceneManager* getSceneManager() const { return mSceneManager; }

    bool isRenderSystemGL() const;
	HGLRC getGlContext() const;
	void setGlContext( HGLRC glContext );

    bool loadMesh(const QString& sFileName);
    void clearScene();

    Ogre::Mesh* currentMesh(int index = 0);

    Q_SIGNAL void sceneCreated();

private:
    void setupResources();
    void registerHlms();

    Ogre::Item* loadV2Mesh(QString meshName);
    Ogre::Item* loadV1Mesh(QString meshName);
    void createBall(int x, int y);

private:
	std::vector<OgreWidget*> mOgreWidgets;
    int mIdCount = 0;

    Ogre::Root* mRoot = nullptr;
	Ogre::Timer* mTimer = nullptr;
    Ogre::RenderSystem* mCurrentRenderSystem = nullptr;

    Ogre::SceneManager* mSceneManager = nullptr;
    Ogre::v1::OverlaySystem * mOverlaySystem = nullptr;
    MyHlmsListener* myHlmsListener = nullptr;

	std::string mResourcesCfg;
	std::string mPluginsCfg;
	
	HGLRC mGlContext = 0;

    Ogre::SceneNode* mMeshRootNode = nullptr;

    std::vector<Ogre::MeshPtr> mLoadedV2Meshes;
    std::vector<Ogre::v1::MeshPtr> mLoadedV1Meshes;
};
